<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>welcome to my crib</title>
  <meta name="description" content="check out my cool stuff">
  <meta name="author" content="murfalo">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="murfalo">
  <meta property="og:description" content="check out my cool stuff">
  <meta property="og:url" content="https://murfalo.com">
  <meta property="og:image" content="https://murfalo.com/img/murfalo.png">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="murfalo">
  <meta name="twitter:description" content="check out my cool stuff">
  <meta name="twitter:image" content="https://murfalo.com/img/murfalo.png">

  <!-- Favicons -->
  <link rel="icon" href="/img/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="theme-color" content="#18181b">

  <style>
    *,
    *::before,
    *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    ::selection {
      background: rgba(139, 92, 246, 0.35);
      color: #e4e4e7;
    }

    :root {
      --color-bg: #18181b;
      --color-text: #e4e4e7;
      --color-muted: #a1a1aa;
      --color-primary: #8b5cf6;
      --color-primary-glow: rgba(139, 92, 246, 0.4);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background-color: var(--color-bg);
      color: var(--color-text);
      min-height: 100dvh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
      user-select: none;
    }

    /* Noise texture overlay */
    .noise {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 2;
      opacity: 0.035;
    }

    /* Lava lamp canvas */
    .lava-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      cursor: grab;
    }

    .lava-canvas:active {
      cursor: grabbing;
    }

    .container {
      text-align: center;
      padding: 2rem;
      animation: fadeIn 0.6s ease-out;
      position: relative;
      z-index: 1;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(12px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    .avatar {
      width: 160px;
      height: 160px;
      border-radius: 50%;
      object-fit: cover;
      box-shadow: 0 0 24px var(--color-primary-glow);
      transition: box-shadow 0.3s ease;
      cursor: pointer;
    }

    .avatar:hover {
      box-shadow: 0 0 40px var(--color-primary-glow), 0 0 80px rgba(139, 92, 246, 0.15);
    }

    h1 {
      margin-top: 1.25rem;
      font-size: 2.5rem;
      font-weight: 700;
      letter-spacing: -0.02em;
    }

    .bio {
      margin-top: 0.4rem;
      font-size: 1.1rem;
      color: var(--color-muted);
    }

    .cursor {
      display: inline-block;
      width: 2px;
      height: 1.1em;
      background: var(--color-primary);
      margin-left: 1px;
      vertical-align: text-bottom;
      animation: blink 0.6s step-end infinite;
    }

    @keyframes blink {
      50% { opacity: 0; }
    }

    nav {
      margin-top: 1.75rem;
      display: flex;
      gap: 1.25rem;
      justify-content: center;
      flex-wrap: wrap;
    }

    nav a {
      color: var(--color-muted);
      transition: color 0.2s ease, transform 0.2s ease;
      display: inline-flex;
    }

    nav a:hover {
      color: var(--color-primary);
      transform: translateY(-2px);
    }

    nav a svg {
      width: 26px;
      height: 26px;
      fill: currentColor;
    }

    .bubble-hint {
      position: fixed;
      bottom: 1.25rem;
      left: 0;
      right: 0;
      text-align: center;
      font-style: italic;
      font-size: 0.85rem;
      color: var(--color-muted);
      z-index: 3;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .bubble-hint.visible {
      opacity: 0.5;
    }

    /* Screen shake */
    @keyframes shake {
      0%, 100% { transform: translate(0, 0); }
      10% { transform: translate(-4px, 2px); }
      20% { transform: translate(4px, -2px); }
      30% { transform: translate(-3px, -3px); }
      40% { transform: translate(3px, 3px); }
      50% { transform: translate(-2px, 4px); }
      60% { transform: translate(2px, -4px); }
      70% { transform: translate(-3px, 2px); }
      80% { transform: translate(3px, -2px); }
      90% { transform: translate(-2px, 3px); }
    }

    .shake {
      animation: shake 0.5s ease-in-out;
    }

  </style>
</head>
<body>
  <!-- Lava lamp canvas -->
  <canvas class="lava-canvas" id="lava"></canvas>

  <!-- Noise texture -->
  <svg class="noise" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">
    <filter id="noiseFilter">
      <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch"/>
    </filter>
    <rect width="100%" height="100%" filter="url(#noiseFilter)"/>
  </svg>

  <main class="container">
    <img class="avatar" src="img/murfalo.png" alt="murfalo — dog in purple hoodie and sunglasses" width="160" height="160" draggable="false">
    <h1>murfalo</h1>
    <p class="bio">check out my <span id="typed"></span><span class="cursor"></span></p>

    <nav aria-label="Social links">
      <!-- Email -->
      <a href="mailto:howdy@murfalo.com" aria-label="Email">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 4H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 2-8 5-8-5h16zm0 12H4V8l8 5 8-5v10z"/></svg>
      </a>

      <!-- GitHub -->
      <a href="https://github.com/murfalo" rel="me" aria-label="GitHub">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.477 2 2 6.477 2 12c0 4.42 2.865 8.166 6.839 9.489.5.092.682-.217.682-.482 0-.237-.009-.866-.013-1.7-2.782.604-3.369-1.341-3.369-1.341-.454-1.155-1.11-1.462-1.11-1.462-.908-.62.069-.608.069-.608 1.003.07 1.531 1.03 1.531 1.03.892 1.529 2.341 1.087 2.91.831.092-.646.35-1.086.636-1.337-2.22-.253-4.555-1.11-4.555-4.943 0-1.091.39-1.984 1.029-2.683-.103-.253-.446-1.27.098-2.647 0 0 .84-.269 2.75 1.025A9.578 9.578 0 0 1 12 6.836a9.59 9.59 0 0 1 2.504.337c1.909-1.294 2.747-1.025 2.747-1.025.546 1.377.203 2.394.1 2.647.64.699 1.028 1.592 1.028 2.683 0 3.842-2.339 4.687-4.566 4.935.359.309.678.919.678 1.852 0 1.336-.012 2.415-.012 2.743 0 .267.18.578.688.48C19.138 20.163 22 16.418 22 12c0-5.523-4.477-10-10-10z"/></svg>
      </a>

      <!-- Google Scholar -->
      <a href="https://scholar.google.com/citations?user=zC_z7igAAAAJ" aria-label="Google Scholar">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 24a7 7 0 1 1 0-14 7 7 0 0 1 0 14zm0-2a5 5 0 1 0 0-10 5 5 0 0 0 0 10z"/><path d="m21.5 10-9.5-8-9.5 8h5.5v4h2v-4z"/></svg>
      </a>

      <!-- LinkedIn -->
      <a href="https://www.linkedin.com/in/murfalo" rel="me" aria-label="LinkedIn">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 0 1-2.063-2.065 2.064 2.064 0 1 1 2.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
      </a>

      <!-- Twitter / X -->
      <a href="https://twitter.com/mvrfalo" rel="me" aria-label="Twitter">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
      </a>

      <!-- Bluesky -->
      <a href="https://bsky.app/profile/murfalo.bsky.social" rel="me" aria-label="Bluesky">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.25c2.095 2.633 4.35 7.98 4.35 7.98s.456 7.332-4.35 4.613c-4.806 2.719-4.35-4.613-4.35-4.613S9.905 4.883 12 2.25zm-4.35 15.7c1.467.88 3.127.37 4.35-.664 1.223 1.034 2.883 1.544 4.35.665 1.963-1.178 2.152-3.291 2.003-4.214.62.327 1.62.532 2.397-.108 1.12-.923.65-2.6-.75-3.629-1.64-1.207-3.042-.635-3.042-.635s.404-4.329-1.258-6.607C14.198.966 12.877.25 12 .25s-2.198.716-3.7 2.508c-1.662 2.278-1.258 6.607-1.258 6.607s-1.402-.572-3.042.635c-1.4 1.03-1.87 2.706-.75 3.63.777.64 1.777.434 2.397.107-.149.923.04 3.036 2.003 4.214z"/></svg>
      </a>

      <!-- Instagram -->
      <a href="https://instagram.com/mvrfalo" rel="me" aria-label="Instagram">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zM12 0C8.741 0 8.333.014 7.053.072 2.695.272.273 2.69.073 7.052.014 8.333 0 8.741 0 12c0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98C8.333 23.986 8.741 24 12 24c3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98C15.668.014 15.259 0 12 0zm0 5.838a6.162 6.162 0 1 0 0 12.324 6.162 6.162 0 0 0 0-12.324zM12 16a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm6.406-11.845a1.44 1.44 0 1 0 0 2.881 1.44 1.44 0 0 0 0-2.881z"/></svg>
      </a>
    </nav>
  </main>
  <p class="bubble-hint" id="bubble-hint"></p>

  <script>
    // --- Typewriter ---
    (() => {
      const words = [
        "molecules", "proteins", "RNA", "simulations", "amino acids",
        "force fields", "PDBs", "molecular dynamics", "nucleotides",
        "Terraria mods", "repos", "commits", "side quests", "loot",
        "inventory", "patch notes", "sludge", "slop",
        "cool stuff", "dog pics", "drip", "hoodie collection", "sunglasses",
        "crib", "vibes", "hot takes", "links", "fits", "socials",
        "Boston accent", "British accent", "Debbie Marks impression",
        "cozy corner", "manifesto", "mixtape", "magnum opus",
        "search history", "bookmarks",
        "wares", "lore", "origin story", "final form", "spaghetti code",
        "Bankai", "fireball jutsu", "power level", "stand",
        "stone world", "domain expansion", "equivalent exchange", "bizarre adventure",
        "crystal structures", "peptides", "nucleic acids"
      ];

      const el = document.getElementById("typed");
      let queue = [];
      let i = 0;

      function shuffle(arr) {
        for (let j = arr.length - 1; j > 0; j--) {
          const k = Math.floor(Math.random() * (j + 1));
          [arr[j], arr[k]] = [arr[k], arr[j]];
        }
        return arr;
      }

      function next() {
        if (queue.length === 0) queue = shuffle([...words]);
        return queue.pop();
      }

      function typeWord(word) {
        if (i <= word.length) {
          el.textContent = word.slice(0, i);
          i++;
          setTimeout(() => typeWord(word), 55);
        } else {
          setTimeout(() => deleteWord(word), 1500);
        }
      }

      function deleteWord(word) {
        if (i > 0) {
          i--;
          el.textContent = word.slice(0, i);
          setTimeout(() => deleteWord(word), 35);
        } else {
          setTimeout(() => { i = 0; typeWord(next()); }, 300);
        }
      }

      typeWord(next());
    })();

    // --- Interactive lava lamp (WebGL metaball shader) + Easter eggs ---
    (() => {
      const canvas = document.getElementById("lava");
      const gl = canvas.getContext("webgl");
      if (!gl) { console.warn("WebGL not available — lava lamp disabled"); return; }

      // --- Constants ---
      const SPEED_CLAMP = 3.5;
      const SPEED_CLAMP_FLYING = 14;
      const DAMPING = 0.984;

      const IDLE_UNIFORM_R = 25;
      const IDLE_RADIUS_LERP = 0.03;
      const IDLE_NUDGE_FRAMES = [900, 1500, 2400];
      const IDLE_DANCE_START = 3000;
      const IDLE_SHAPE_DURATION = 360;
      const IDLE_SHAPE_BLEND = 120;

      const CURSOR_R_REST = 52;
      const CURSOR_R_CLICK = 90;
      const CURSOR_SPRING_K = 0.12;
      const CURSOR_SPRING_DAMP = 0.55;
      const CURSOR_TRAIL_LAG = 0.35;

      const WALL_SPRING = 0.15;
      const WALL_DAMP = 0.92;

      const POP_RADIUS = 250;
      const POP_BONUS_COUNT = 4;
      const REASSEMBLE_RADIUS = 150;
      const REASSEMBLE_DELAY = 180;

      const BLOB_FADE_RATE = 0.95;
      const BLOB_FADE_MIN = 2;
      const BLOB_FADE_RATE_GOHOME = 0.97;

      const SPEW_INTERVAL = 4;
      const MAX_BLOBS = 48;

      const MOUSE_SPEED_DECAY = 0.9;
      const MOUSE_PUSH_RANGE = 400;
      const MOUSE_REPEL_RANGE = 900;
      const MOUSE_ATTRACT_RANGE = 600;
      const MOUSE_PROXIMITY_DAMP = 200;

      const HINT_FADE_MS = 250;
      const HINT_DISPLAY_MS = 2500;

      const SPIN_MAX = 20;
      const SPIN_ACCEL = 0.6;
      const SPIN_DECEL = 0.985;
      const HINT_AT_BLOB = [1, 10, 25];

      function smoothstep01(x) {
        const t = x < 0 ? 0 : x > 1 ? 1 : x;
        return t * t * (3 - 2 * t);
      }

      // --- State ---
      let W, H;

      // Input
      let mx = null, my = null;
      let mouseSpeed = 0;
      let mouseDown = false;
      let isTouch = false;
      let cursorRadius = CURSOR_R_REST;
      let cursorRadiusVel = 0;
      let cursorTrailX = null, cursorTrailY = null;

      // Animation time
      let time = 0;
      let lastInteractionTime = 0;

      // Pop / reassemble
      let hasPopped = false;
      let popFrame = 0;
      let hasReassembled = false;
      let reassembleHintShown = false;

      // Party mode
      let partyMode = false;
      let hueOffset = 0;

      // Idle
      let idleMode = false;
      let idleShapeIndex = 0;
      let prevIdleShapeIndex = 0;
      let idleShapeSwitchTime = 0;
      let idleDanceStart = 0;
      let idleRadiusFactor = 1.0;
      let idleHinted = false;

      // Avatar spin
      let isSpinning = false;
      let avatarHeld = false;
      let spinAngle = 0;
      let spinSpeed = 0;
      let spinResetTimer = 0;
      let spewCooldown = 0;
      let spewCount = 0;
      let vomitHintIndex = 0;

      // Shake
      let lastShakeTime = 0;

      // Idle formation shapes (normalized offsets from center, y-down screen coords)
      const shapes = [
        // Heart
        [
          {x: 0, y: -0.08},
          {x: -0.15, y: -0.22},
          {x: -0.27, y: -0.08},
          {x: -0.17, y: 0.1},
          {x: 0, y: 0.27},
          {x: 0.17, y: 0.1},
          {x: 0.27, y: -0.08},
          {x: 0.15, y: -0.22},
        ],
        // Letter M
        [
          {x: -0.25, y: 0.2},
          {x: -0.25, y: -0.2},
          {x: -0.1, y: 0.02},
          {x: 0, y: -0.12},
          {x: 0.1, y: 0.02},
          {x: 0.25, y: -0.2},
          {x: 0.25, y: 0.2},
          {x: 0, y: 0.2},
        ],
        // Smiley
        [
          {x: -0.1, y: -0.12},
          {x: 0.1, y: -0.12},
          {x: -0.2, y: 0.05},
          {x: -0.1, y: 0.16},
          {x: 0, y: 0.19},
          {x: 0.1, y: 0.16},
          {x: 0.2, y: 0.05},
          {x: 0, y: -0.25},
        ],
      ];

      function resize() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      resize();
      window.addEventListener("resize", resize);

      const welcomeBacks = ["welcome back!", "oh hi!", "you're back!", "missed you :)", "whoa! didn't see you there", "act natural"];
      function recordInteraction() {
        lastInteractionTime = time;
        if (idleHinted) {
          idleHinted = false;
          const msg = welcomeBacks[Math.floor(Math.random() * welcomeBacks.length)];
          showHint(msg, 1);
        }
        if (idleMode) idleMode = false;
      }

      window.addEventListener("mousemove", e => {
        if (mx !== null) {
          const dx = e.clientX - mx;
          const dy = e.clientY - my;
          mouseSpeed = Math.sqrt(dx * dx + dy * dy);
        }
        mx = e.clientX; my = e.clientY;
        recordInteraction();
      });
      window.addEventListener("touchmove", e => {
        const tx = e.touches[0].clientX, ty = e.touches[0].clientY;
        if (mx !== null) {
          const dx = tx - mx, dy = ty - my;
          mouseSpeed = Math.sqrt(dx * dx + dy * dy);
        }
        mx = tx; my = ty;
        recordInteraction();
      }, { passive: true });
      window.addEventListener("mouseleave", () => {
        mx = null; my = null; mouseSpeed = 0; mouseDown = false;
        cursorTrailX = null; cursorTrailY = null;
      });
      window.addEventListener("mousedown", () => { mouseDown = true; recordInteraction(); });
      window.addEventListener("mouseup", () => { mouseDown = false; });
      window.addEventListener("touchstart", e => {
        isTouch = true;
        mouseDown = true;
        const tx = e.touches[0].clientX, ty = e.touches[0].clientY;
        mx = tx; my = ty;
        recordInteraction();
      }, { passive: true });
      window.addEventListener("touchend", () => { mouseDown = false; isTouch = false; });

      // Keydown for idle tracking
      window.addEventListener("keydown", () => { recordInteraction(); });

      // --- Shaders ---
      const vsSource = `
        attribute vec2 a_pos;
        void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }
      `;

      const fsSource = `
        precision highp float;
        uniform float u_time;
        uniform float u_hue;
        uniform vec3 u_blobs[64];

        vec3 rgb2hsv(vec3 c) {
          vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
          vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
          vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
          float d = q.x - min(q.w, q.y);
          float e = 1.0e-10;
          return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c) {
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        float hash(vec2 p) {
          return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        void main() {
          vec2 uv = gl_FragCoord.xy;
          float field = 0.0;

          for (int i = 0; i < 64; i++) {
            vec2 delta = uv - u_blobs[i].xy;
            float r = u_blobs[i].z;
            float distSq = dot(delta, delta);
            field += (r * r) / max(distSq, 1.0);
          }

          vec3 bg = vec3(0.094, 0.094, 0.106);
          float threshold = 0.65;

          float dist = abs(field - threshold);
          float edge = exp(-dist * 35.0);
          float glow = exp(-dist * 14.0) * 0.3;
          float interior = smoothstep(threshold - 0.02, threshold + 0.02, field);

          vec3 neonBright = vec3(0.75, 0.40, 1.0);
          vec3 neonGlow = vec3(0.50, 0.20, 0.85);
          vec3 interiorColor = vec3(0.12, 0.06, 0.22);

          if (u_hue > 0.001) {
            vec3 hb = rgb2hsv(neonBright);
            hb.x = fract(hb.x + u_hue);
            neonBright = hsv2rgb(hb);

            vec3 hg = rgb2hsv(neonGlow);
            hg.x = fract(hg.x + u_hue);
            neonGlow = hsv2rgb(hg);

            vec3 hi = rgb2hsv(interiorColor);
            hi.x = fract(hi.x + u_hue);
            interiorColor = hsv2rgb(hi);
          }

          vec3 col = bg;
          col = mix(col, interiorColor, interior * 0.35);
          col += neonGlow * glow;
          col += neonBright * edge * 1.5;

          float pulseBright = 0.9 + 0.1 * sin(u_time * 2.0);
          col *= mix(1.0, pulseBright, edge);

          float dither = (hash(gl_FragCoord.xy + u_time) - 0.5) / 255.0 * 2.0;
          col += dither;

          gl_FragColor = vec4(col, 1.0);
        }
      `;

      function compileShader(src, type) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(s));
          return null;
        }
        return s;
      }

      const vs = compileShader(vsSource, gl.VERTEX_SHADER);
      const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
      const prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(prog));
        return;
      }
      gl.useProgram(prog);

      // Fullscreen quad
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
      const aPos = gl.getAttribLocation(prog, "a_pos");
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      // Uniform locations
      const uTime = gl.getUniformLocation(prog, "u_time");
      const uHue = gl.getUniformLocation(prog, "u_hue");
      const uBlobs = [];
      for (let i = 0; i < 64; i++) {
        uBlobs.push(gl.getUniformLocation(prog, `u_blobs[${i}]`));
      }

      // --- Blob physics: 3 large + 5 medium = 8 blobs ---
      const ORIGINAL_COUNT = 8;
      // Scale blob radii for smaller viewports (tuned for ~900px min dimension)
      const viewScale = Math.min(1, Math.min(W, H) / 900);
      function makeBlob(rMin, rMax) {
        return {
          x: 0, y: 0, vx: 0, vy: 0,
          r: (rMin + Math.random() * (rMax - rMin)) * viewScale,
          phaseX: Math.random() * Math.PI * 2,
          phaseY: Math.random() * Math.PI * 2,
          freqX: 0.00015 + Math.random() * 0.00025,
          freqY: 0.00015 + Math.random() * 0.00025,
          buoyancy: (Math.random() - 0.5) * 0.002,
        };
      }
      const blobs = [
        ...Array.from({length: 3}, () => makeBlob(90, 128)),   // large
        ...Array.from({length: 5}, () => makeBlob(49, 83)),    // medium
      ];
      // Store original radii for reassembly reset
      const originalRadii = blobs.map(b => b.r);

      // Start blobs in a ring around center card
      {
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 2;
        for (let i = 0; i < blobs.length; i++) {
          const angle = (i / blobs.length) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
          const dist = 80 + Math.random() * 60;
          blobs[i].x = cx + Math.cos(angle) * dist;
          blobs[i].y = cy + Math.sin(angle) * dist;
        }
      }

      const hintEl = document.getElementById("bubble-hint");
      // Priority queue: lower number = higher priority
      // 0 = top (pop, avatar), 1 = high (reassemble), 2 = normal, 3 = low (visits)
      const hintQueue = []; // [{text, pri}]
      let hintState = "idle"; // "idle" | "visible" | "fading-out"
      let hintDisplayTimer = 0;
      let hintFadeTimer = 0;
      let hintCurrentPri = 99;

      function showHint(text, pri) {
        if (pri === undefined) pri = 2;
        // Top priority: clear everything lower
        if (pri === 0) {
          for (let i = hintQueue.length - 1; i >= 0; i--) {
            if (hintQueue[i].pri > pri) hintQueue.splice(i, 1);
          }
        }
        // Low priority: only queue if nothing is showing and queue is empty
        if (pri === 3 && (hintState !== "idle" || hintQueue.length > 0)) return;
        hintQueue.push({text, pri});
        // Sort by priority (stable — equal priorities keep insertion order)
        hintQueue.sort((a, b) => a.pri - b.pri);
        processHintQueue();
      }

      function processHintQueue() {
        if (hintQueue.length === 0) return;
        const fadeMs = HINT_FADE_MS;

        if (hintState === "idle") {
          const item = hintQueue.shift();
          hintEl.textContent = item.text;
          hintEl.classList.add("visible");
          hintState = "visible";
          hintCurrentPri = item.pri;
          clearTimeout(hintDisplayTimer);
          hintDisplayTimer = setTimeout(() => {
            hintEl.classList.remove("visible");
            hintState = "fading-out";
            hintCurrentPri = 99;
            hintFadeTimer = setTimeout(() => {
              hintState = "idle";
              processHintQueue();
            }, fadeMs);
          }, HINT_DISPLAY_MS);
        } else if (hintState === "visible") {
          // Only interrupt if incoming has equal or higher priority
          if (hintQueue[0].pri <= hintCurrentPri) {
            clearTimeout(hintDisplayTimer);
            hintEl.classList.remove("visible");
            hintState = "fading-out";
            hintCurrentPri = 99;
            clearTimeout(hintFadeTimer);
            hintFadeTimer = setTimeout(() => {
              hintState = "idle";
              processHintQueue();
            }, fadeMs);
          }
        }
      }

      // --- Feature E: Avatar Spin + Vomit Orbs (JS-driven rotation) ---
      const avatarEl = document.querySelector(".avatar");
      const vomitHints = ["wheee", "WHEEEEE", "I'm gonna be sick"];

      function spewBlobs() {
        if (blobs.length >= MAX_BLOBS) return;
        const rect = avatarEl.getBoundingClientRect();
        const ax = rect.left + rect.width / 2;
        const ay = rect.top + rect.height / 2;

        if (!partyMode) {
          partyMode = true;
          hueOffset = 0;
          hasReassembled = false;
        }

        // Sprinkler: direction follows current spin angle
        const sprayRad = spinAngle * Math.PI / 180;
        const b = makeBlob(15, 25);
        b.x = ax;
        b.y = ay;
        b.vx = Math.cos(sprayRad) * (12 + Math.random() * 4);
        b.vy = Math.sin(sprayRad) * (12 + Math.random() * 4);
        b.freeFlying = true;
        blobs.push(b);
        spewCount++;

        // Show hints at specific blob milestones
        if (vomitHintIndex < vomitHints.length && spewCount >= HINT_AT_BLOB[vomitHintIndex]) {
          showHint(vomitHints[vomitHintIndex], 0);
          vomitHintIndex++;
        }
      }

      function startSpin(e) {
        e.stopPropagation();
        e.preventDefault();
        recordInteraction();
        clearTimeout(spinResetTimer);
        isSpinning = true;
        avatarHeld = true;
        spewCooldown = 0;
        spewBlobs();
      }

      avatarEl.addEventListener("mousedown", startSpin);
      avatarEl.addEventListener("touchstart", startSpin, { passive: false });

      function stopHold() {
        if (!avatarHeld) return;
        avatarHeld = false;
        // Party mode lingers for 5s after release, then fades
        clearTimeout(spinResetTimer);
        spinResetTimer = setTimeout(() => { partyMode = false; }, 5000);
      }
      window.addEventListener("mouseup", stopHold);
      window.addEventListener("touchend", stopHold);

      // --- Feature I: Shake to Scatter (Mobile) ---
      function handleMotion(e) {
        const acc = e.acceleration || e.accelerationIncludingGravity;
        if (!acc || acc.x === null) return;
        const mag = Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z);
        const threshold = e.acceleration ? 15 : 25;
        if (mag > threshold && Date.now() - lastShakeTime > 2000) {
          lastShakeTime = Date.now();
          recordInteraction();
          for (const b of blobs) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 5 + Math.random() * 3;
            b.vx = Math.cos(angle) * speed;
            b.vy = Math.sin(angle) * speed;
          }
          showHint("earthquake!");
        }
      }

      // iOS 13+ needs permission from a user gesture
      window.addEventListener("touchstart", function reqMotion() {
        window.removeEventListener("touchstart", reqMotion);
        if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
          DeviceMotionEvent.requestPermission().then(state => {
            if (state === "granted") window.addEventListener("devicemotion", handleMotion);
          }).catch(() => {});
        }
      }, { passive: true });
      // Non-iOS devices
      if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission !== "function") {
        window.addEventListener("devicemotion", handleMotion);
      }

      // --- Physics loop ---
      function updateAvatarSpin() {
        // Continuous sprinkle while avatar is held down
        if (avatarHeld && isSpinning) {
          spewCooldown--;
          if (spewCooldown <= 0) {
            spewBlobs();
            spewCooldown = SPEW_INTERVAL;
          }
        }

        // Avatar spin physics: accelerate while held, decelerate on release
        if (avatarHeld) {
          spinSpeed = Math.min(spinSpeed + SPIN_ACCEL, SPIN_MAX);
          spinAngle += spinSpeed;
          avatarEl.style.transform = `rotate(${spinAngle}deg)`;
        } else if (spinSpeed > 0.5) {
          // Fast decel phase: just slow down
          spinSpeed *= SPIN_DECEL;
          spinAngle += spinSpeed;
          avatarEl.style.transform = `rotate(${spinAngle}deg)`;
        } else if (isSpinning) {
          // Settle phase: spring toward nearest upright (multiple of 360)
          const remainder = ((spinAngle % 360) + 360) % 360;
          const target = remainder > 180
            ? spinAngle + (360 - remainder)
            : spinAngle - remainder;
          const diff = target - spinAngle;
          spinAngle += diff * 0.08;
          avatarEl.style.transform = `rotate(${spinAngle}deg)`;
          if (Math.abs(diff) < 0.5) {
            spinAngle = target;
            spinSpeed = 0;
            isSpinning = false;
            avatarEl.style.transform = "";
          }
        }
      }

      function updateHue() {
        if (partyMode) {
          hueOffset += 0.005;
          if (hueOffset > 1) hueOffset -= 1;
        } else if (Math.abs(hueOffset) > 0.001) {
          // Smoothly return to original hue via shortest path around the circle
          if (hueOffset > 0.5) {
            hueOffset += 0.008;
            if (hueOffset > 1) hueOffset -= 1;
          } else {
            hueOffset *= 0.97;
          }
        } else {
          hueOffset = 0;
        }
      }

      function updateCursorTrail() {
        if (mx !== null) {
          if (cursorTrailX === null) { cursorTrailX = mx; cursorTrailY = my; }
          cursorTrailX += (mx - cursorTrailX) * CURSOR_TRAIL_LAG;
          cursorTrailY += (my - cursorTrailY) * CURSOR_TRAIL_LAG;
        } else {
          cursorTrailX = null;
          cursorTrailY = null;
        }
      }

      function updateIdleTimeline() {
        // Idle nudges → dance → go home
        // Timeline (seconds idle): 15→hello?, 25→helloooo, 40→anyone there?,
        // 50→start dancing, ~75→head home
        if (!idleMode) {
          const idleFrames = time - lastInteractionTime;
          if (idleFrames === IDLE_NUDGE_FRAMES[0]) { showHint("hello?", 3); idleHinted = true; }
          if (idleFrames === IDLE_NUDGE_FRAMES[1]) showHint("helloooo", 3);
          if (idleFrames === IDLE_NUDGE_FRAMES[2]) showHint("anyone there?", 3);
          if (idleFrames === IDLE_DANCE_START) {
            showHint("fine, I'll entertain myself");
            idleMode = true;
            idleShapeIndex = 0;
            prevIdleShapeIndex = 0;
            idleShapeSwitchTime = time;
            idleDanceStart = time;
          }
        }

        // Cycle idle shapes
        if (idleMode && time - idleShapeSwitchTime > IDLE_SHAPE_DURATION) {
          prevIdleShapeIndex = idleShapeIndex;
          idleShapeIndex = (idleShapeIndex + 1) % shapes.length;
          idleShapeSwitchTime = time;
          for (let k = 0; k < blobs.length; k++) {
            blobs[k].vx *= 0.3;
            blobs[k].vy *= 0.3;
          }
        }

        // Smoothly shrink blob radii during idle dance
        const targetRadiusFactor = idleMode ? 0.0 : 1.0;
        idleRadiusFactor += (targetRadiusFactor - idleRadiusFactor) * IDLE_RADIUS_LERP;
        const idleR = IDLE_UNIFORM_R * viewScale;
        for (let k = 0; k < Math.min(ORIGINAL_COUNT, blobs.length); k++) {
          blobs[k].r = idleR + (originalRadii[k] - idleR) * idleRadiusFactor;
        }
      }

      function updateBlobs() {
        // Pop: triggers on hover near center or click
        if (!hasPopped) {
          let shouldPop = false;
          if (mx !== null) {
            const dx = mx - W / 2;
            const dy = my - H / 2;
            if (Math.sqrt(dx * dx + dy * dy) < POP_RADIUS) shouldPop = true;
          }
          if (mouseDown) shouldPop = true;
          if (shouldPop) {
            hasPopped = true;
            popFrame = time;
            for (let i = 0; i < blobs.length; i++) {
              const b = blobs[i];
              const angle = (i / blobs.length) * Math.PI * 2 + (Math.random() - 0.5) * 1.5;
              const speed = 8 + Math.random() * 4;
              b.vx = Math.cos(angle) * speed;
              b.vy = Math.sin(angle) * speed;
              b.freeFlying = true;
            }
            showHint("oh no! you popped my bubble", 0);

            const cx = W / 2, cy = H / 2;
            for (let i = 0; i < POP_BONUS_COUNT; i++) {
              const angle = (i / POP_BONUS_COUNT) * Math.PI * 2;
              const b = makeBlob(25, 35);
              b.x = cx;
              b.y = cy;
              b.vx = Math.cos(angle) * 6;
              b.vy = Math.sin(angle) * 6;
              blobs.push(b);
            }
          }
        }

        // Reassemble detection
        if (hasPopped && !hasReassembled && time - popFrame > REASSEMBLE_DELAY) {
          let cx = 0, cy = 0;
          const n = Math.min(ORIGINAL_COUNT, blobs.length);
          for (let i = 0; i < n; i++) { cx += blobs[i].x; cy += blobs[i].y; }
          cx /= n; cy /= n;
          let allClose = true;
          for (let i = 0; i < n; i++) {
            const dx = blobs[i].x - cx, dy = blobs[i].y - cy;
            if (Math.sqrt(dx * dx + dy * dy) > REASSEMBLE_RADIUS) { allClose = false; break; }
          }
          if (allClose) {
            if (idleMode) {
              if (blobs.length <= ORIGINAL_COUNT) {
                hasReassembled = true;
                if (!reassembleHintShown) { reassembleHintShown = true; showHint("ok bye", 3); }
                idleMode = false;
              }
            } else {
              hasReassembled = true;
              if (!reassembleHintShown) { reassembleHintShown = true; showHint("aw, you put it back :)", 1); }
            }
          }
        }

        // Gradually fade extra blobs after reassembly (pause during vomit)
        if (hasReassembled && !partyMode && blobs.length > ORIGINAL_COUNT) {
          for (let j = blobs.length - 1; j >= ORIGINAL_COUNT; j--) {
            blobs[j].r *= BLOB_FADE_RATE;
            if (blobs[j].r < BLOB_FADE_MIN) {
              blobs.splice(j, 1);
            }
          }
        }

        // Spring-animate cursor metaball radius
        const targetRadius = (mouseDown ? CURSOR_R_CLICK : CURSOR_R_REST) * viewScale;
        cursorRadiusVel += (targetRadius - cursorRadius) * CURSOR_SPRING_K;
        cursorRadiusVel *= CURSOR_SPRING_DAMP;
        cursorRadius += cursorRadiusVel;

        // Per-blob physics loop
        for (let i = 0; i < blobs.length; i++) {
          const b = blobs[i];

          // Idle formation steering
          if (idleMode) {
            const danceSec = (time - idleDanceStart) / 60;
            const homeBlend = smoothstep01(hasPopped ? (danceSec - 25) / 5 : 0);
            const shapeFade = smoothstep01((time - idleShapeSwitchTime) / IDLE_SHAPE_BLEND);

            const curShape = shapes[idleShapeIndex];
            const prevShape = shapes[prevIdleShapeIndex];
            const scale = Math.min(W, H) * 0.7;
            const cx = W / 2, cy = H / 2;

            // Fade out extra blobs during go-home
            if (homeBlend > 0 && i >= ORIGINAL_COUNT) {
              b.r *= BLOB_FADE_RATE_GOHOME;
              if (b.r < BLOB_FADE_MIN) {
                blobs.splice(i, 1);
                i--;
                continue;
              }
            }

            let tx, ty;
            if (i < curShape.length) {
              const prevX = cx + prevShape[i].x * scale;
              const prevY = cy + prevShape[i].y * scale;
              const curX = cx + curShape[i].x * scale;
              const curY = cy + curShape[i].y * scale;
              const shapeX = prevX + (curX - prevX) * shapeFade;
              const shapeY = prevY + (curY - prevY) * shapeFade;
              tx = shapeX + (cx - shapeX) * homeBlend;
              ty = shapeY + (cy - shapeY) * homeBlend;
              b.vx += (tx - b.x) * 0.003;
              b.vy += (ty - b.y) * 0.003;
            } else {
              const angle = time * 0.002 + i * 1.3;
              const orbitR = Math.min(W, H) * 0.45;
              const orbitX = cx + Math.cos(angle) * orbitR;
              const orbitY = cy + Math.sin(angle) * orbitR;
              tx = orbitX + (cx - orbitX) * homeBlend;
              ty = orbitY + (cy - orbitY) * homeBlend;
              b.vx += (tx - b.x) * 0.001;
              b.vy += (ty - b.y) * 0.001;
            }
          }

          // sinusoidal drift (slow, languid)
          b.vx += Math.sin(time * b.freqX + b.phaseX) * 0.0002;
          b.vy += Math.cos(time * b.freqY + b.phaseY) * 0.0002;

          // buoyancy
          b.vy += b.buoyancy;

          // blob-blob interactions (skip if either blob is free-flying)
          for (let j = i + 1; j < blobs.length; j++) {
            const o = blobs[j];
            if (b.freeFlying || o.freeFlying) continue;
            const dx = o.x - b.x;
            const dy = o.y - b.y;
            const distSq = dx * dx + dy * dy;
            const combinedR = b.r + o.r;
            const maxInteract = combinedR * 3.0;
            if (distSq > maxInteract * maxInteract) continue;
            const dist = Math.sqrt(distSq);

            if (dist < 1) continue;

            if (dist < combinedR * 0.5) {
              const force = 0.003 * (1 - dist / (combinedR * 0.5));
              const fx = (dx / dist) * force;
              const fy = (dy / dist) * force;
              b.vx -= fx; b.vy -= fy;
              o.vx += fx; o.vy += fy;
            } else if (dist < combinedR * 3.0) {
              const force = 0.0012 * (dist - combinedR * 0.5) / (combinedR * 2.5);
              const fx = (dx / dist) * force;
              const fy = (dy / dist) * force;
              b.vx += fx; b.vy += fy;
              o.vx -= fx; o.vy -= fy;
            }
          }

          // Mouse interaction — push until popped + escaped, then suck
          if (mx !== null && !b.freeFlying && !idleMode) {
            const dx = b.x - mx;
            const dy = b.y - my;
            const dist = Math.max(Math.sqrt(dx * dx + dy * dy), 50);
            const escaped = hasPopped && time - popFrame > 150;

            if (!escaped) {
              if (dist < MOUSE_PUSH_RANGE) {
                const taper = 1.0 - dist / MOUSE_PUSH_RANGE;
                const force = taper * taper * 0.3;
                b.vx += (dx / dist) * force;
                b.vy += (dy / dist) * force;
              }
            } else if (mouseDown && !isTouch) {
              if (dist < MOUSE_REPEL_RANGE) {
                const taper = 1.0 - dist / MOUSE_REPEL_RANGE;
                const force = taper * taper * 0.7;
                b.vx += (dx / dist) * force;
                b.vy += (dy / dist) * force;
              }
            } else if (dist < MOUSE_ATTRACT_RANGE) {
              const speedMult = 1.0 + mouseSpeed * 0.05;
              const taper = 1.0 - dist / MOUSE_ATTRACT_RANGE;
              const force = taper * taper * 0.12 * speedMult;
              b.vx -= (dx / dist) * force;
              b.vy -= (dy / dist) * force;
              if (dist < MOUSE_PROXIMITY_DAMP) {
                const damp = 0.92 + 0.06 * (dist / MOUSE_PROXIMITY_DAMP);
                b.vx *= damp;
                b.vy *= damp;
              }
            }
          }

          // wall springs — soft gooey pushback
          if (b.x < b.r) {
            const pen = (b.r - b.x) / b.r;
            b.vx += pen * WALL_SPRING;
            b.vx *= WALL_DAMP;
          }
          if (b.x > W - b.r) {
            const pen = (b.x - (W - b.r)) / b.r;
            b.vx -= pen * WALL_SPRING;
            b.vx *= WALL_DAMP;
          }
          if (b.y < b.r) {
            const pen = (b.r - b.y) / b.r;
            b.vy += pen * WALL_SPRING;
            b.vy *= WALL_DAMP;
          }
          if (b.y > H - b.r) {
            const pen = (b.y - (H - b.r)) / b.r;
            b.vy -= pen * WALL_SPRING;
            b.vy *= WALL_DAMP;
          }

          // damping
          b.vx *= DAMPING;
          b.vy *= DAMPING;

          // clamp speed (free-flying blobs get a higher clamp to reach the wall)
          const clamp = b.freeFlying ? SPEED_CLAMP_FLYING : SPEED_CLAMP;
          const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
          if (speed > clamp) {
            b.vx = (b.vx / speed) * clamp;
            b.vy = (b.vy / speed) * clamp;
          }

          b.x += b.vx;
          b.y += b.vy;

          // Free-flying blobs become normal on wall contact or when they lose momentum
          if (b.freeFlying) {
            const spd = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
            if (spd < SPEED_CLAMP || b.x <= b.r || b.x >= W - b.r || b.y <= b.r || b.y >= H - b.r) {
              b.freeFlying = false;
            }
          }

          // Allow center past edge by up to half radius (wall smoosh)
          b.x = Math.max(-b.r * 0.5, Math.min(W + b.r * 0.5, b.x));
          b.y = Math.max(-b.r * 0.5, Math.min(H + b.r * 0.5, b.y));
        }
      }

      function update() {
        time++;
        mouseSpeed *= MOUSE_SPEED_DECAY;
        updateAvatarSpin();
        updateHue();
        updateCursorTrail();
        updateIdleTimeline();
        updateBlobs();
      }

      function draw() {
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        gl.uniform1f(uTime, time * 0.01);
        gl.uniform1f(uHue, hueOffset);

        let slot = 0;
        const maxSlots = 64;

        // Physics blobs
        for (let i = 0; i < blobs.length && slot < maxSlots - 2; i++) {
          gl.uniform3f(uBlobs[slot], blobs[i].x * dpr, (H - blobs[i].y) * dpr, blobs[i].r * dpr);
          slot++;
        }

        // Primary cursor metaball
        if (mx !== null) {
          gl.uniform3f(uBlobs[slot], mx * dpr, (H - my) * dpr, cursorRadius * dpr);
        } else {
          gl.uniform3f(uBlobs[slot], 0.0, 0.0, 0.0);
        }
        slot++;

        // Trailing cursor for natural deformation when moving
        if (mx !== null && cursorTrailX !== null) {
          const stretch = Math.min(mouseSpeed / 12, 1.0);
          const trailR = cursorRadius * 0.55 * stretch;
          gl.uniform3f(uBlobs[slot], cursorTrailX * dpr, (H - cursorTrailY) * dpr, trailR * dpr);
        } else {
          gl.uniform3f(uBlobs[slot], 0.0, 0.0, 0.0);
        }
        slot++;

        // Zero out remaining slots
        while (slot < maxSlots) {
          gl.uniform3f(uBlobs[slot], 0.0, 0.0, 0.0);
          slot++;
        }

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }
      loop();

      // --- Feature G: Return Visitor Memory ---
      try {
        let visits = parseInt(localStorage.getItem("murfalo_visits") || "0", 10);
        visits++;
        localStorage.setItem("murfalo_visits", visits.toString());
        setTimeout(() => {
          if (visits === 2) showHint("oh, you're back!", 3);
          else if (visits === 3) showHint("you again?", 3);
          else if (visits <= 5) showHint("at this point we're friends", 3);
          else if (visits <= 9) showHint("ok you basically live here now", 3);
          else if (visits < 25) showHint("welcome home :)", 3);
          else showHint("visit #" + visits + ". you're dedicated", 3);
        }, 5000);
      } catch (e) { /* localStorage unavailable */ }

      // --- Random avatar hint ---
      const avatarNudges = [
        "psst... click my avatar",
        "try clicking the dog",
        "that avatar looks clickable...",
        "go on, give the dog a spin",
      ];
      const nudgeDelay = (10 + Math.random() * 50) * 1000; // 10-60 seconds
      setTimeout(() => {
        if (!isSpinning && spewCount === 0) {
          const pick = avatarNudges[Math.floor(Math.random() * avatarNudges.length)];
          showHint(pick, 3);
        }
      }, nudgeDelay);
    })();
  </script>
</body>
</html>
